#if ECS_COMPILE_IL2CPP_OPTIONS
[Unity.IL2CPP.CompilerServices.Il2CppSetOptionAttribute(Unity.IL2CPP.CompilerServices.Option.NullChecks, false),
 Unity.IL2CPP.CompilerServices.Il2CppSetOptionAttribute(Unity.IL2CPP.CompilerServices.Option.ArrayBoundsChecks, false),
 Unity.IL2CPP.CompilerServices.Il2CppSetOptionAttribute(Unity.IL2CPP.CompilerServices.Option.DivideByZeroChecks, false)]
#endif
public struct FilterBag<#ITEMS_TYPE#> #ITEMS_WHERE# {

    public readonly int Length;
    public int index;
    private readonly int max;
    private readonly int min;
    [Unity.Collections.NativeDisableParallelForRestriction] private Unity.Collections.NativeArray<bool> inFilter;
    [Unity.Collections.NativeDisableParallelForRestriction] private Unity.Collections.NativeArray<int> filterEntities;
    
    #ITEMS_BUFFER#

    public FilterBag(Filter filter, Unity.Collections.Allocator allocator) {

        var world = filter.world;
        var arrEntities = world.currentState.storage.cache;
        filter.GetBounds(out var min, out var max);
        if (min > max) {

            min = 0;
            max = -1;

        }

        if (min < 0) min = 0;
        ++max;
        if (max >= arrEntities.Length) max = arrEntities.Length - 1;
        this.index = min - 1;
        this.Length = filter.Count;
        this.min = min;
        this.max = max;
        
        this.inFilter = new Unity.Collections.NativeArray<bool>(world.GetFilter(filter.id).dataContains.arr, allocator);
        this.filterEntities = new Unity.Collections.NativeArray<int>(filter.Count, allocator);
        var idx = 0;
        foreach (var entity in filter) {
            
            this.filterEntities[idx++] = entity.id;
            
        }
        
        #ITEMS_INIT#
        
    }

    public int GetEntityIdByIndex(int index) {

        return this.filterEntities[index];

    }
    
    public void Push() {

        var world = Worlds.currentWorld;
        var changedCount = 0;
        #ITEMS_PUSH#
        if (changedCount > 0) world.UpdateAllFilters();
        
        this.Dispose();
        
    }

    public void Revert() {
        
        #ITEMS_DISPOSE#
        this.Dispose();

    }

    public ref Entity Get() {

        return ref Worlds.currentWorld.GetEntityById(this.index);

    }

    public void Reset() {

        this.index = this.min - 1;

    }
    
    public bool MoveNext() {
        
        ++this.index;
        while (this.index <= this.max && this.inFilter[this.index] == false) {

            ++this.index;

        }

        return this.index <= this.max;

    }
    
    private void Dispose() {
        
        this.inFilter.Dispose();
        this.filterEntities.Dispose();
        
    }

    #region API
    #ITEMS_METHODS#
    #endregion

}
