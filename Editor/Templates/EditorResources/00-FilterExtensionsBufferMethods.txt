public void RemoveT#INDEX#(int index) { this.componentOps.Write(new Op() { entityIndex = index, componentId = AllComponentTypes<T#INDEX#>.burstTypeId.Data, code = 2, }); }
public void Set(int index, in T#INDEX# component) {
    var entityId = this.indexes[index];
    ref var componentData = ref this.regs[#INDEX#].value.Get<Component<T#INDEX#>>(this.allocator, this.indexes[index]);
    if (DataBlittableBurstBufferUtils.NeedToPush(in this.allocator, this.tick, ref this.entityVersions, entityId, ref componentData, in component) == true) {
        this.componentOps.Write(new Op() { entityIndex = index, componentId = AllComponentTypes<T#INDEX#>.burstTypeId.Data, code = 1, });
        componentData.data = component;
    }
}
public ref T#INDEX# GetT#INDEX#(int index) {
    this.componentOps.Write(new Op() { entityIndex = index, componentId = AllComponentTypes<T#INDEX#>.burstTypeId.Data, code = 1, });
    return ref this.regs[#INDEX#].value.Get<Component<T#INDEX#>>(this.allocator, this.indexes[index]).data;
}
public ref readonly T#INDEX# ReadT#INDEX#(int index) => ref this.regs[#INDEX#].value.Get<Component<T#INDEX#>>(this.allocator, this.indexes[index]).data;
public bool HasT#INDEX#(int index) => this.regs[#INDEX#].value.Has<T#INDEX#>(this.allocator, this.indexes[index]);
public long GetVersionT#INDEX#(int index) => this.regs[#INDEX#].value.Get<Component<T#INDEX#>>(this.allocator, this.indexes[index]).version;
